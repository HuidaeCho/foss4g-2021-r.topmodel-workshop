#!/usr/bin/env python3
# GRASS GIS module for creating r.topmodel parameters file
#
# AUTHOR:       Huidae Cho
# COPYRIGHT:    (C) 2015 by Huidae Cho
# LICENSE:      GNU Affero General Public License v3

#%module
#% description: Creates r.topmodel parameters and topidxstats files.
#% keywords: hydrology
#% keywords: watershed
#% overwrite: yes
#%end
#%option G_OPT_R_ELEV
#%end
#%option
#% key: prefix
#% type: string
#% description: Input/output map prefix
#% required: yes
#%end
#%option G_OPT_M_COORDS
#% description: Coordinates of outlet point
#% required: yes
#%end
#%option
#% key: hacksorder
#% type: integer
#% description: Hack's order of the study stream. Default: the highest order
#% required: no
#%end
#%flag
#% key: s
#% description: Skip creating intermediate maps that already exist
#%end
#%flag
#% key: r
#% description: Do not set the computational region to DEM
#%end

import sys
import os
import math

import grass.script as grass


def main():
    global skip, overwrite, mapset

    elev = options["elevation"]
    prefix = options["prefix"]
    coords = options["coordinates"]
    hacksorder = options["hacksorder"]
    skip = flags["s"]
    region = not flags["r"]
    overwrite = grass.overwrite()
    mapset = grass.gisenv()["MAPSET"]

    # output maps
    drain = prefix + "drain"
    streams = prefix + "streams"
    hack = prefix + "hack"
    outlet = prefix + "outlet"
    flowsite = prefix + "flowsite"
    basin = prefix + "basin"
    flds = prefix + "flds"
    flus = prefix + "flus"
    fldsus = prefix + "fldsus"
    lfp = prefix + "lfp"
    outlets = prefix + "outlets"
    subbasin = prefix + "subbasin"
    params_file = prefix + "params.txt"
    topidx = prefix + "topidx"
    topidxstats = prefix + "topidxstats.txt"

    find_subbasin_outlets(lfp, outlets)
    delineate_subbasins(outlets, drain, subbasin)
    create_params_file(elev, prefix, basin, lfp, subbasin, coords, hacksorder,
            params_file)
    calculate_topidx(elev, topidx)
    create_topidxstats_file(topidx, topidxstats)


def find_subbasin_outlets(lfp, outlets):
    global overwrite

    grass.message(_("===== Finding subbasin outlets ====="))

    if skip_vector(outlets):
        return

    p = grass.pipe_command("v.db.select", flags="fc",
            map=lfp, columns="cat")
    for line in p.stdout:
        cat = int(line.rstrip("\n"))
        break
    p.wait()
    if p.returncode != 0:
        grass.fatal(_("Cannot find subbasin outlets"))

    p = grass.feed_command("v.segment", overwrite=overwrite,
            input=lfp, output=outlets)
    for i in range(1, 10):
        p.stdin.write("P %d %d -%f%%\n" % (i, cat, i*10.0))
    p.stdin.close()
    p.wait()
    if p.returncode != 0:
        grass.fatal(_("Cannot find subbasin outlets"))


def delineate_subbasins(outlets, drain, subbasin):
    global overwrite

    grass.message(_("===== Delineating subbasins ====="))

    p = grass.pipe_command("v.to.db", flags="p", map=outlets, option="coor")
    i = 1
    for line in p.stdout:
        output = line.rstrip("\n").split("|")
        if output[0] == "cat":
            continue
        name = "%s%d" % (subbasin, i)
        if skip_raster(name):
            continue

        outlet_coords = "%s,%s" % (output[1], output[2])
        if grass.run_command("r.water.outlet", overwrite=overwrite,
                input=drain, output=name, coordinates=outlet_coords) != 0:
            grass.fatal(_("Cannot delineate subbasins"))
        i += 1
    p.wait()
    if p.returncode != 0:
        grass.fatal(_("Cannot delineate subbasins"))


def create_params_file(elev, prefix, basin, lfp, subbasin, coords, hacksorder,
        params_file):
    grass.message(_("===== Creating parameters file ====="))

    total_area = 0.0
    p = grass.pipe_command("r.stats", flags="an", quiet=True, input=basin)
    for line in p.stdout:
        total_area = float(line.rstrip("\n").split(" ")[1])
        break
    p.wait()
    if p.returncode != 0 or total_area == 0.0:
        grass.fatal(_("Cannot calculate the watershed area"))

    total_length = 0.0
    p = grass.pipe_command("v.to.db", flags="p", quiet=True,
            map=lfp, option="length")
    for line in p.stdout:
        total_length = float(line.rstrip("\n").split("|")[1])
        break
    p.wait()
    if p.returncode != 0 or total_length == 0.0:
        grass.fatal(_("Cannot calculate the main stream length"))

    if not overwrite and os.path.exists(params_file):
        grass.fatal(_("%s already exists.") % params_file)

    if hacksorder == "":
        order = ""
    else:
        order = " hacksorder=%s" % hacksorder

    f = open(params_file, "w")
    f.write("""\
# Generated by %s elevation=%s prefix=%s coordinates=%s%s
# Subcatchment name
%s

################################################################################
# A [m^2]: Subcatchment area
%f

################################################################################
# qs0 [m/h]: Initial subsurface flow per unit area
1

# lnTe [ln(m^2/h)]: Areal average of ln(T0)
1

# m [m]: Scaling parameter
0.1

# Sr0 [m]: Initial root zone storage deficit
0.005

# Srmax [m]: Maximum root zone storage deficit
0.01

# td [h]: Unsaturated zone time delay per unit storage deficit if greater than 0
#  OR
# -alpha: Effective vertical hydraulic gradient if not greater than 0.
1

# vch [m/h]: Main channel routing velocity
100

# vr [m/h]: Internal subcatchment routing velocity
100

################################################################################
# infex: Calculate infiltration excess if not zero (integer)
0

# K0 [m/h]: Surface hydraulic conductivity
0.1

# psi [m]: Wetting front suction
0.1

# dtheta: Water content change across the wetting front
0.1

################################################################################
# d [m]: Distance from the catchment outlet
#               The first value should be the main stream distance from
#               the subcatchment outlet to the catchment outlet.
# Ad_r:  Cumulative area ratio of subcatchment (0.0 to 1.0)
#               The first and last values should be 0 and 1, respectively.

# d Ad_r
""" % (os.path.basename(sys.argv[0]), elev, prefix, coords, order,
        prefix.replace("_", " ").rstrip().title(), total_area))

    f.write("0 0\n")
    for i in range(1, 10):
        area = 0.0
        p = grass.pipe_command("r.stats", flags="an", quiet=True,
                input="%s%d" % (subbasin, i))
        for line in p.stdout:
            area = float(line.rstrip("\n").split(" ")[1])
            break
        p.wait()
        if p.returncode != 0:
            return 1
        if area == 0.0:
            grass.fatal(_("Cannot calculate the area of subbasin%d") % i)
        f.write("%f %f\n" % (0.1*i*total_length, (total_area-area)/total_area))
    f.write("%f 1\n" % total_length)
    f.close()


def calculate_topidx(elev, topidx):
    global overwrite

    grass.message(_("===== Calculating topographic index ====="))

    if skip_raster(topidx):
        return

    if grass.run_command("r.topidx", overwrite=overwrite,
            input=elev, output=topidx) != 0:
        grass.fatal(_("Cannot calculate the topographic index"))


def create_topidxstats_file(topidx, topidxstats):
    global overwrite

    grass.message(_("===== Creating topographic index statistics file ====="))

    if grass.run_command("r.topmodel", flags="p", overwrite=overwrite,
            topidx=topidx, outtopidxstats=topidxstats) != 0:
        grass.fatal(_("Cannot create topographic index statistics file"))


def raster_exists(map):
    global mapset
    return grass.find_file(map, element="cell", mapset=mapset)["file"] != ""


def skip_raster(map):
    global skip
    return skip and raster_exists(map)


def vector_exists(map):
    global mapset
    return grass.find_file(map, element="vector", mapset=mapset)["file"] != ""


def skip_vector(map):
    global skip
    return skip and vector_exists(map)


if __name__ == "__main__":
    options, flags = grass.parser()
    sys.exit(main())
